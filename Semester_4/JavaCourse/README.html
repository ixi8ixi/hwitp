
<h3 id="student">Домашнее задание 1. Обход файлов</h3><ol><li>
            Разработайте класс <tt>Walk</tt>, осуществляющий подсчет хеш-сумм файлов.
            <ol><li>
                    Формат запуска:
                    <pre>java Walk &lt;входной файл&gt; &lt;выходной файл&gt;</pre></li><li>
                    Входной файл содержит список файлов, которые требуется обойти.
                </li><li>
                    Выходной файл должен содержать по одной строке для каждого файла. 
                    Формат строки:
                    <pre>&lt;шестнадцатеричная хеш-сумма&gt; &lt;путь к файлу&gt;</pre></li><li>
                    Для подсчета хеш-суммы используйте 
                    алгоритм <a href="https://en.wikipedia.org/wiki/SHA-256">SHA-256</a>
                    (поддержка есть в стандартной библиотеке).
                    
                    
                </li><li>
                    Если при чтении файла возникают ошибки, укажите в качестве
                    его хеш-суммы все нули.
                </li><li>
                    Кодировка входного и выходного файлов &mdash; UTF-8.
                </li><li>
                    Размеры файлов могут превышать размер оперативной памяти.
                </li><li>
                    Пример
                    <table class="black"><tr><th>Входной файл</th></tr><tr><td><pre>
samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file
                        </pre></td></tr><tr><th>Выходной файл</th></tr><tr><td><pre>
6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b samples/1
6b51d431df5d7f141cbececcf79edf3dd861c3b4069f0b11661a3eefacbba918 samples/12
a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3 samples/123
03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4 samples/1234
6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b samples/1
40aff2e9d2d8922e47afd4648e6967497158785fbd1da870e7110266bf944880 samples/binary
0000000000000000000000000000000000000000000000000000000000000000 samples/no-such-file
                        </pre></td></tr></table></li></ol></li><li>
            Сложный вариант:
            <ol><li>
                    Разработайте класс <tt>RecursiveWalk</tt>,
                    осуществляющий подсчет хеш-сумм файлов в
                    директориях.
                </li><li>
                    Входной файл содержит список файлов и директорий,
                    которые требуется обойти. Обход директорий осуществляется
                    рекурсивно.
                </li><li>
                    Пример:
                    <table class="black"><tr><th>Входной файл</th></tr><tr><td><pre>
samples/binary
samples
samples/no-such-file
                        </pre></td></tr><tr><th>Выходной файл</th></tr><tr><td><pre>
40aff2e9d2d8922e47afd4648e6967497158785fbd1da870e7110266bf944880 samples/binary
6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b samples/1
6b51d431df5d7f141cbececcf79edf3dd861c3b4069f0b11661a3eefacbba918 samples/12
a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3 samples/123
03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4 samples/1234
40aff2e9d2d8922e47afd4648e6967497158785fbd1da870e7110266bf944880 samples/binary
0000000000000000000000000000000000000000000000000000000000000000 samples/no-such-file
                        </pre></td></tr></table></li></ol></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    Дизайн и обработку исключений, диагностику ошибок.
                </li><li>
                    Программа должна корректно завершаться даже в случае ошибки.
                </li><li>
                    Корректная работа с вводом-выводом.
                </li><li>
                    Отсутствие утечки ресурсов.
                </li><li>
                    Возможность повторного использования кода.
                </li></ul></li><li>
            Требования к оформлению задания.
            <ul><li>
                    Проверяется исходный код задания.
                </li><li>
                    Весь код должен находиться в пакете
                    <tt>info.kgeorgiy.ja.фамилия.walk</tt>.
                </li></ul></li></ol><p><h3 id="student">Домашнее задание 2. Множество на массиве</h3><ol><li>
            Разработайте класс <code>ArraySet</code>,
            реализующий неизменяемое упорядоченное множество.
            <ul><li>
                    Класс <code>ArraySet</code> должен реализовывать
                    интерфейс 
                    <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/SortedSet.html">SortedSet</a>
                    (простой вариант)
                    или 
                    <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/NavigableSet.html">NavigableSet</a> 
                    (сложный вариант).
                </li><li>
                    Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
                </li></ul></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    Применение стандартных коллекций.
                </li><li>
                    Избавление от повторяющегося кода.
                </li></ul></li></ol><h3 id="student">Домашнее задание 3. Студенты</h3><ol><li>
            Разработайте класс <code>StudentDB</code>,
            осуществляющий поиск по базе данных студентов.
            <ul><li>
                    Класс <code>StudentDB</code> должен реализовывать
                    интерфейс <code>StudentQuery</code> (простой вариант)
                    или <code>GroupQuery</code> (сложный вариант).
                </li><li>
                    Каждый метод должен состоять из ровно одного оператора.
                    При этом длинные операторы надо разбивать на несколько строк.
                </li></ul></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    применение лямбда-выражений и потоков;
                </li><li>
                    избавление от повторяющегося кода.
                </li></ul></li></ol><h3 id="implementor">Домашнее задание 4. Implementor</h3><ol><li>
            Реализуйте класс <code>Implementor</code>, 
            генерирующий реализации классов и интерфейсов.
            <ul><li>
                    Аргумент командной строки: полное имя класса/интерфейса, для
                    которого требуется сгенерировать реализацию.
                </li><li>
                    В результате работы должен быть сгенерирован java-код класса с суффиксом
                    <code>Impl</code>, расширяющий (реализующий) указанный класс (интерфейс).
                </li><li>
                    Сгенерированный класс должен компилироваться без ошибок.
                </li><li>
                    Сгенерированный класс не должен быть абстрактным.
                </li><li>
                    Методы сгенерированного класса должны игнорировать свои аргументы и
                    возвращать значения по умолчанию.
                </li></ul></li><li>
            В задании выделяются три варианта:
            <ul><li><em>Простой</em> &mdash; <code>Implementor</code> должен уметь реализовывать
                    только интерфейсы (но не классы). Поддержка generics не требуется.
                </li><li><em>Сложный</em> &mdash; <code>Implementor</code> должен уметь реализовывать
                    и классы, и интерфейсы. Поддержка generics не требуется.
                </li><li><em>Бонусный</em> &mdash; <code>Implementor</code> должен уметь реализовывать
                    generic-классы и интерфейсы. Сгенерированный код должен иметь
                    корректные параметры типов и не порождать <code>UncheckedWarning</code>.
                </li></ul></li></ol><h3 id="implementor-jar">Домашнее задание 5. Jar Implementor</h3><p>
        Это домашнее задание <b>связано</b> с предыдущим
        и будет приниматься только с ним.
        Предыдущее домашнее задание отдельно сдать будет нельзя.
    </p><ol><li>
            Создайте <code>.jar</code>-файл, содержащий скомпилированный
            <code>Implementor</code> и сопутствующие классы.
            <ul><li>
                    Созданный <code>.jar</code>-файл должен запускаться командой
                    <code>java -jar</code>.
                </li><li>
                    Запускаемый <code>.jar</code>-файл должен принимать те же аргументы командной
                    строки, что и класс <code>Implementor</code>.
                </li></ul></li><li>
            Модифицируйте <code>Implemetor</code> так, чтобы
            при запуске с аргументами <code>-jar имя-класса файл.jar</code>
            он генерировал <code>.jar</code>-файл с реализацией
            соответствующего класса (интерфейса).
        </li><li>
            Для проверки, кроме исходного кода так же должны быть представлены:
            <ul><li>
                    скрипт для создания запускаемого <code>.jar</code>-файла, 
                    в том числе исходный код манифеста;
                </li><li>
                    запускаемый <code>.jar</code>-файл.
                </li></ul></li><li><b>Сложный вариант</b>. Решение должно быть модуляризовано.
        </li></ol><h3 id="implementor-javadoc">Домашнее задание 6. Javadoc</h3><p>
        Это домашнее задание <b>связано</b> с двумя предыдущими
        и будет приниматься только с ними.
        Предыдущие домашнее задание отдельно сдать будет нельзя.
    </p><ol><li>
            Документируйте класс <code>Implementor</code> и сопутствующие классы 
            с применением Javadoc.
            <ul><li>
                    Должны быть документированы все классы и все члены классов, 
                    в том числе <code>private</code>.
                </li><li>
                    Документация должна генерироваться без предупреждений.
                </li><li>
                    Сгенерированная документация должна содержать корректные 
                    ссылки на классы стандартной библиотеки.
                </li></ul></li><li>
            Для проверки, кроме исходного кода так же должны быть представлены:
            <ul><li>
                    скрипт для генерации документации;
                </li><li>
                    сгенерированная документация.
                </li></ul></li></ol><h3 id="concurrent">Домашнее задание 7. Итеративный параллелизм</h3><ol><li>
            Реализуйте класс <tt>IterativeParallelism</tt>,
            который будет обрабатывать списки в несколько потоков.
        </li><li>
            В простом варианте должны быть реализованы следующие методы:
            <ul><li><tt>minimum(threads, list, comparator)</tt> &mdash;
                    первый минимум;
                </li><li><tt>maximum(threads, list, comparator)</tt> &mdash;
                    первый максимум;
                </li><li><tt>all(threads, list, predicate)</tt> &mdash;
                    проверка, что все элементы списка, удовлетворяют предикату;                    
                </li><li><tt>any(threads, list, predicate)</tt> &mdash;
                    проверка, что существует элемент списка, удовлетворяющий предикату.
                </li><li><tt>count(threads, list, predicate)</tt> &mdash;
                    подсчёт числа элементов списка, удовлетворяющих предикату.
                </li></ul></li><li>
            В сложном варианте должны быть дополнительно реализованы следующие методы:
            <ul><li><tt>filter(threads, list, predicate)</tt> &mdash;
                    вернуть список, содержащий элементы удовлетворяющие предикату;
                </li><li><tt>map(threads, list, function)</tt> &mdash;
                    вернуть список, содержащий результаты применения функции;
                </li><li><tt>join(threads, list)</tt> &mdash;
                    конкатенация строковых представлений элементов списка.
                </li></ul></li><li>
            Во все функции передается параметр <tt>threads</tt> &mdash;
            сколько потоков надо использовать при вычислении.
            Вы можете рассчитывать, что число потоков относительно мало.
        </li><li>
            Не следует рассчитывать на то, что переданные компараторы,
            предикаты и функции работают быстро.
        </li><li>
            При выполнении задания <strong>нельзя</strong> использовать
            <i>Concurrency Utilities</i>.
        </li></ol><h3 id="mapper">Домашнее задание 8. Параллельный запуск</h3><ol><li>
            Напишите класс <tt>ParallelMapperImpl</tt>, реализующий интерфейс
            <tt>ParallelMapper</tt>.
<pre>
public interface ParallelMapper extends AutoCloseable {
    &lt;T, R&gt; List&lt;R&gt; map(
        Function&lt;? super T, ? extends R&gt; f,
        List&lt;? extends T&gt; args
    ) throws InterruptedException;

    @Override
    void close();
}
</pre><ul><li>
                    Метод <tt>run</tt> должен параллельно вычислять
                    функцию <tt>f</tt> на каждом из указанных аргументов
                    (<tt>args</tt>).
                </li><li>
                    Метод <tt>close</tt> должен останавливать все рабочие потоки.
                </li><li>
                    Конструктор <tt>ParallelMapperImpl(int threads)</tt>
                    создает <tt>threads</tt> рабочих потоков, которые могут
                    быть использованы для распараллеливания.
                </li><li>
                    К одному <tt>ParallelMapperImpl</tt> могут одновременно обращаться
                    несколько клиентов.
                </li><li>
                    Задания на исполнение должны накапливаться в очереди и обрабатываться
                    в порядке поступления.
                </li><li>
                    В реализации не должно быть активных ожиданий.
                </li></ul></li><li>
            Доработайте класс <tt>IterativeParallelism</tt> так,
            чтобы он мог использовать <tt>ParallelMapper</tt>.
            <ul><li>
                    Добавьте конструктор <tt>IterativeParallelism(ParallelMapper)</tt></li><li>
                    Методы класса должны делить работу на <tt>threads</tt>
                    фрагментов и исполнять их при помощи <tt>ParallelMapper</tt>.
                </li><li>
                    При наличии <tt>ParallelMapper</tt> сам
                    <tt>IterativeParallelism</tt> новые потоки создавать не должен.
                </li><li>
                    Должна быть возможность одновременного запуска и работы
                    нескольких клиентов, использующих один <tt>ParallelMapper</tt>.
                </li></ul></li><li>
            При выполнении задания всё ещё <strong>нельзя</strong> использовать
            <i>Concurrency Utilities</i>.