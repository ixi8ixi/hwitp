### Домашнее задание 1\. Обход файлов

1.  Разработайте класс <tt>Walk</tt>, осуществляющий подсчет хеш-сумм файлов.
    1.  Формат запуска:

        <pre>java Walk <входной файл> <выходной файл></pre>

    2.  Входной файл содержит список файлов, которые требуется обойти.
    3.  Выходной файл должен содержать по одной строке для каждого файла. Формат строки:

        <pre><шестнадцатеричная хеш-сумма> <путь к файлу></pre>

    4.  Для подсчета хеш-суммы используйте алгоритм [SHA-256](https://en.wikipedia.org/wiki/SHA-256) (поддержка есть в стандартной библиотеке).
    5.  Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы все нули.
    6.  Кодировка входного и выходного файлов — UTF-8.
    7.  Размеры файлов могут превышать размер оперативной памяти.
    8.  Пример

        <table class="black">

        <tbody>

        <tr>

        <th>Входной файл</th>

        </tr>

        <tr>

        <td>

        <pre>samples/1
        samples/12
        samples/123
        samples/1234
        samples/1
        samples/binary
        samples/no-such-file
                                </pre>

        </td>

        </tr>

        <tr>

        <th>Выходной файл</th>

        </tr>

        <tr>

        <td>

        <pre>6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b samples/1
        6b51d431df5d7f141cbececcf79edf3dd861c3b4069f0b11661a3eefacbba918 samples/12
        a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3 samples/123
        03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4 samples/1234
        6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b samples/1
        40aff2e9d2d8922e47afd4648e6967497158785fbd1da870e7110266bf944880 samples/binary
        0000000000000000000000000000000000000000000000000000000000000000 samples/no-such-file
                                </pre>

        </td>

        </tr>

        </tbody>

        </table>

2.  Сложный вариант:
    1.  Разработайте класс <tt>RecursiveWalk</tt>, осуществляющий подсчет хеш-сумм файлов в директориях.
    2.  Входной файл содержит список файлов и директорий, которые требуется обойти. Обход директорий осуществляется рекурсивно.
    3.  Пример:

        <table class="black">

        <tbody>

        <tr>

        <th>Входной файл</th>

        </tr>

        <tr>

        <td>

        <pre>samples/binary
        samples
        samples/no-such-file
                                </pre>

        </td>

        </tr>

        <tr>

        <th>Выходной файл</th>

        </tr>

        <tr>

        <td>

        <pre>40aff2e9d2d8922e47afd4648e6967497158785fbd1da870e7110266bf944880 samples/binary
        6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b samples/1
        6b51d431df5d7f141cbececcf79edf3dd861c3b4069f0b11661a3eefacbba918 samples/12
        a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3 samples/123
        03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4 samples/1234
        40aff2e9d2d8922e47afd4648e6967497158785fbd1da870e7110266bf944880 samples/binary
        0000000000000000000000000000000000000000000000000000000000000000 samples/no-such-file
                                </pre>

        </td>

        </tr>

        </tbody>

        </table>

3.  При выполнении задания следует обратить внимание на:
    *   Дизайн и обработку исключений, диагностику ошибок.
    *   Программа должна корректно завершаться даже в случае ошибки.
    *   Корректная работа с вводом-выводом.
    *   Отсутствие утечки ресурсов.
    *   Возможность повторного использования кода.
4.  Требования к оформлению задания.
    *   Проверяется исходный код задания.
    *   Весь код должен находиться в пакете <tt>info.kgeorgiy.ja.фамилия.walk</tt>.

### Домашнее задание 2\. Множество на массиве

1.  Разработайте класс `ArraySet`, реализующий неизменяемое упорядоченное множество.
    *   Класс `ArraySet` должен реализовывать интерфейс [SortedSet](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/SortedSet.html) (простой вариант) или [NavigableSet](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/NavigableSet.html) (сложный вариант).
    *   Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
2.  При выполнении задания следует обратить внимание на:
    *   Применение стандартных коллекций.
    *   Избавление от повторяющегося кода.

### Домашнее задание 3\. Студенты

1.  Разработайте класс `StudentDB`, осуществляющий поиск по базе данных студентов.
    *   Класс `StudentDB` должен реализовывать интерфейс `StudentQuery` (простой вариант) или `GroupQuery` (сложный вариант).
    *   Каждый метод должен состоять из ровно одного оператора. При этом длинные операторы надо разбивать на несколько строк.
2.  При выполнении задания следует обратить внимание на:
    *   применение лямбда-выражений и потоков;
    *   избавление от повторяющегося кода.

### Домашнее задание 4\. Implementor

1.  Реализуйте класс `Implementor`, генерирующий реализации классов и интерфейсов.
    *   Аргумент командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
    *   В результате работы должен быть сгенерирован java-код класса с суффиксом `Impl`, расширяющий (реализующий) указанный класс (интерфейс).
    *   Сгенерированный класс должен компилироваться без ошибок.
    *   Сгенерированный класс не должен быть абстрактным.
    *   Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
2.  В задании выделяются три варианта:
    *   _Простой_ — `Implementor` должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не требуется.
    *   _Сложный_ — `Implementor` должен уметь реализовывать и классы, и интерфейсы. Поддержка generics не требуется.
    *   _Бонусный_ — `Implementor` должен уметь реализовывать generic-классы и интерфейсы. Сгенерированный код должен иметь корректные параметры типов и не порождать `UncheckedWarning`.

### Домашнее задание 5\. Jar Implementor

Это домашнее задание **связано** с предыдущим и будет приниматься только с ним. Предыдущее домашнее задание отдельно сдать будет нельзя.

1.  Создайте `.jar`-файл, содержащий скомпилированный `Implementor` и сопутствующие классы.
    *   Созданный `.jar`-файл должен запускаться командой `java -jar`.
    *   Запускаемый `.jar`-файл должен принимать те же аргументы командной строки, что и класс `Implementor`.
2.  Модифицируйте `Implemetor` так, чтобы при запуске с аргументами `-jar имя-класса файл.jar` он генерировал `.jar`-файл с реализацией соответствующего класса (интерфейса).
3.  Для проверки, кроме исходного кода так же должны быть представлены:
    *   скрипт для создания запускаемого `.jar`-файла, в том числе исходный код манифеста;
    *   запускаемый `.jar`-файл.
4.  **Сложный вариант**. Решение должно быть модуляризовано.

### Домашнее задание 6\. Javadoc

Это домашнее задание **связано** с двумя предыдущими и будет приниматься только с ними. Предыдущие домашнее задание отдельно сдать будет нельзя.

1.  Документируйте класс `Implementor` и сопутствующие классы с применением Javadoc.
    *   Должны быть документированы все классы и все члены классов, в том числе `private`.
    *   Документация должна генерироваться без предупреждений.
    *   Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки.
2.  Для проверки, кроме исходного кода так же должны быть представлены:
    *   скрипт для генерации документации;
    *   сгенерированная документация.

### Домашнее задание 7\. Итеративный параллелизм

1.  Реализуйте класс <tt>IterativeParallelism</tt>, который будет обрабатывать списки в несколько потоков.
2.  В простом варианте должны быть реализованы следующие методы:
    *   <tt>minimum(threads, list, comparator)</tt> — первый минимум;
    *   <tt>maximum(threads, list, comparator)</tt> — первый максимум;
    *   <tt>all(threads, list, predicate)</tt> — проверка, что все элементы списка, удовлетворяют предикату;
    *   <tt>any(threads, list, predicate)</tt> — проверка, что существует элемент списка, удовлетворяющий предикату.
    *   <tt>count(threads, list, predicate)</tt> — подсчёт числа элементов списка, удовлетворяющих предикату.
3.  В сложном варианте должны быть дополнительно реализованы следующие методы:
    *   <tt>filter(threads, list, predicate)</tt> — вернуть список, содержащий элементы удовлетворяющие предикату;
    *   <tt>map(threads, list, function)</tt> — вернуть список, содержащий результаты применения функции;
    *   <tt>join(threads, list)</tt> — конкатенация строковых представлений элементов списка.
4.  Во все функции передается параметр <tt>threads</tt> — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков относительно мало.
5.  Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
6.  При выполнении задания **нельзя** использовать _Concurrency Utilities_.

### Домашнее задание 8\. Параллельный запуск

1.  Напишите класс <tt>ParallelMapperImpl</tt>, реализующий интерфейс <tt>ParallelMapper</tt>.

    <pre>public interface ParallelMapper extends AutoCloseable {
        <T, R> List<R> map(
            Function<? super T, ? extends R> f,
            List<? extends T> args
        ) throws InterruptedException;

        @Override
        void close();
    }
    </pre>

    *   Метод <tt>run</tt> должен параллельно вычислять функцию <tt>f</tt> на каждом из указанных аргументов (<tt>args</tt>).
    *   Метод <tt>close</tt> должен останавливать все рабочие потоки.
    *   Конструктор <tt>ParallelMapperImpl(int threads)</tt> создает <tt>threads</tt> рабочих потоков, которые могут быть использованы для распараллеливания.
    *   К одному <tt>ParallelMapperImpl</tt> могут одновременно обращаться несколько клиентов.
    *   Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
    *   В реализации не должно быть активных ожиданий.
2.  Доработайте класс <tt>IterativeParallelism</tt> так, чтобы он мог использовать <tt>ParallelMapper</tt>.
    *   Добавьте конструктор <tt>IterativeParallelism(ParallelMapper)</tt>
    *   Методы класса должны делить работу на <tt>threads</tt> фрагментов и исполнять их при помощи <tt>ParallelMapper</tt>.
    *   При наличии <tt>ParallelMapper</tt> сам <tt>IterativeParallelism</tt> новые потоки создавать не должен.
    *   Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один <tt>ParallelMapper</tt>.
3.  При выполнении задания всё ещё **нельзя** использовать _Concurrency Utilities_.

#### Домашнее задание 9. Web Crawler

1.  Напишите потокобезопасный класс `WebCrawler`, который будет рекурсивно обходить сайты.
    1.  Класс `WebCrawler` должен иметь конструктор
        
        public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)
        
        *   `downloader` позволяет скачивать страницы и извлекать из них ссылки;
        *   `downloaders` — максимальное число одновременно загружаемых страниц;
        *   `extractors` — максимальное число страниц, из которых одновременно извлекаются ссылки;
        *   `perHost` — максимальное число страниц, одновременно загружаемых c одного хоста. Для определения хоста следует использовать метод `getHost` класса `URLUtils` из тестов.
    2.  Класс `WebCrawler` должен реализовывать интерфейс `Crawler`
        
        public interface Crawler extends AutoCloseable {
            Result download(String url, int depth);
        
            void close();
        }
        
        *   Метод `download` должен рекурсивно обходить страницы, начиная с указанного URL, на указанную глубину и возвращать список загруженных страниц и файлов. Например, если глубина равна 1, то должна быть загружена только указанная страница. Если глубина равна 2, то указанная страница и те страницы и файлы, на которые она ссылается, и так далее.
        *   Метод `download` может вызываться параллельно в нескольких потоках.
        *   Загрузка и обработка страниц (извлечение ссылок) должна выполняться максимально параллельно, с учетом ограничений на число одновременно загружаемых страниц (в том числе с одного хоста) и страниц, с которых загружаются ссылки.
        *   Для распараллеливания разрешается создать до `downloaders + extractors` вспомогательных потоков.
        *   Повторно загружать и/или извлекать ссылки из одной и той же страницы в рамках одного обхода (`download`) запрещается.
        *   Метод `close` должен завершать все вспомогательные потоки.
    3.  Для загрузки страниц должен применяться `Downloader`, передаваемый первым аргументом конструктора.
        
        public interface Downloader {
            public Document download(final String url) throws IOException;
        }
        
        *   Метод `download` загружает документ по его адресу ([URL](http://tools.ietf.org/html/rfc3986)).
        *   Документ позволяет получить ссылки по загруженной странице:
            
            public interface Document {
                List<String> extractLinks() throws IOException;
            }
            
            Ссылки, возвращаемые документом, являются абсолютными и имеют схему `http` или `https`.
    4.  Должен быть реализован метод `main`, позволяющий запустить обход из командной строки
        *   Командная строка
            
            WebCrawler url \[depth \[downloads \[extractors \[perHost\]\]\]\]
            
        *   Для загрузки страниц требуется использовать реализацию `CachingDownloader` из тестов.
2.  Версии задания
    1.  _Простая_ — не требуется учитывать ограничения на число одновременных закачек с одного хоста (`perHost >= downloaders`).
    2.  _Полная_ — требуется учитывать все ограничения.
    3.  _Бонусная_ — сделать параллельный обход в ширину.
3.  Задание подразумевает активное использование Concurrency Utilities, в частности, в решении не должно быть «велосипедов», аналогичных/легко сводящихся к классам из Concurrency Utilities.